/**
 * TODO: Check if the column/row to be added has the same dimension as the rest of the CSV file.
 * TODO: Explain the naming convention for header line in a CSV file; No commas; Ends with "Int", "Dec", "Bool", "Char", "Str"
 * TODO: What if there is no header line.
 * TODO: What if file doesn't exist.
 */

uses data.String

component provides CSVUtilExtension requires data.csv.CSVParser parser, io.Output out, io.Input in, io.File,
data.IntUtil iu, util.Random rand, time.ClockHD, io.TextFile, data.StringUtil su, util.Math math {

    // Used to check the 
    const int dataTypeSizes[] = new int[](1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024)

    bool CSVUtilExtension:addColumn(char filename[], bool hasHeaderLine, char separators[], Data wrappedData[],
                                    opt char columnName[] = "NewColumn", opt int columnNumber) {
        // Check if the new column is not empty.
        if (wrappedData.arrayLength == 0)
            throw new Exception("Parameter \"wrappedData\" is empty.")

        // Infer the types of the columns in the CSV file and build the data template.
        Type templateType = new Type(Type.DATA, 0, 0)

        // Get the header line.
        TextFile csvFile = new TextFile(filename, File.WRITE)
        char headerLine[] = csvFile.readLine()

        String columnNames[] = su.explode(headerLine, ",")

        for (int i = 0; i < columnNames.arrayLength; i++) {
            // Extract the datatype information from the column names.
            for (int j = 0; j < dataTypeSizes.arrayLength; j++) {
                if (su.endsWith(su.trim(columnNames[i].string), "Int$(dataTypeSizes[j])")) {
                    templateType.fields = new Field[](templateType.fields,
                                                      new Field(new Type(Type.INTEGER, 0, math.power(2, j)),
                                                                su.trim(columnNames[i].string)))
                    break
                    }
                    else if (su.endsWith(su.trim(columnNames[i].string), "Dec$(dataTypeSizes[j])")) {
                    templateType.fields = new Field[](templateType.fields,
                                                      new Field(new Type(Type.DECIMAL, 0, math.power(2, j)),
                                                                su.trim(columnNames[i].string)))
                    break
                    }
                    else if (su.endsWith(su.trim(columnNames[i].string), "Str")) {
                    Type charArrayType = new Type(Type.ARRAY, 0, 0, new Field(new Type(Type.INTEGER, Type.F_CHAR, 1)))
                    templateType.fields = new Field[](templateType.fields, new Field(charArrayType, su.trim(columnNames[i].string)))
                    break
                    }
                    else if (j == dataTypeSizes.arrayLength - 1) {
                    throw new Exception("Unsupported CSV data type at column: $(i).")
                    }
                }
            }

        // Reset the read position, since the header line has been read.
        csvFile.setPos(0)

        // Parse the CSV file.
        Data template = new Data() from templateType
        Data csvData[] = parser.parseDocument(csvFile, hasHeaderLine, separators, template)

        // Append the new column if no preference is expressed.
        if (!isset columnNumber) {
            columnNumber = columnNames.arrayLength
            }

        // Construct the new data type for the resulting CSV file.
        Type newTemplateType

        if (columnNumber == 0) {
            newTemplateType = new Type(Type.DATA, 0, 0,
                                       new Field[](new Field(typeof(wrappedData[0]).fields[0].type, columnName), templateType.fields))
            }
            else if (columnNumber < columnNames.arrayLength) {
            newTemplateType = new Type(Type.DATA, 0, 0,
                                       new Field[](dana.sub(templateType.fields, 0, columnNumber - 1),
                                                   new Field(typeof(wrappedData[0]).fields[0].type, columnName),
                                                   dana.sub(templateType.fields, columnNumber, templateType.fields.arrayLength - 1)))
            }
            else if (columnNumber == columnNames.arrayLength) {
            newTemplateType = new Type(Type.DATA, 0, 0,
                                       new Field[](templateType.fields, new Field(typeof(wrappedData[0]).fields[0].type, columnName)))
            }
            else {
                throw new Exception("Parameter \"columnNumber\" exceeds the upper index bound of: $(columnNames.arrayLength - 1).")
            }

        // for (int i = 0; i < templateType.fields.arrayLength; i++) {
        //     out.print("$(templateType.fields[i].name)\n")
        //     }

        // out.print("\n")

        // for (int i = 0; i < newTemplateType.fields.arrayLength; i++) {
        //     out.print("$(newTemplateType.fields[i].name)\n")
        //     }

        // Construct the new CSV data and copy the data across.
        Data newCsvData[] = new Data[csvData.arrayLength] from newTemplateType

        // for (int i = 0; i < typeof(newCsvData[0]).fields.arrayLength; i++) {
        //     out.print("Data field = $(typeof(newCsvData[0]).fields[i].name)\n")
        //     Data d = newCsvData[i]
        //     newCsvData[]
        //     if (d == null)
        //         out.print("Null\n")
        //     d:.0
        //     }

        // int columnValues[] = unwrapIntArray(wrappedData)
        // out.print("typeof(wrappedData).fields[0].type = $(typeof(wrappedData).fields[0].type.class)\n")
        // out.print("typeof(newCsvData[0]).fields[columnNumber].type.class = $(typeof(newCsvData[0]).fields[columnNumber].type.class)\n")
        // out.print("typeof(columnValues[0]).class = $(typeof(columnValues[0]).class)\n")

        // Unwrap the column to be added.
        if (typeof(wrappedData[0]).fields[0].type.class == Type.INTEGER) {
            int columnValues[] = unwrapIntArray(wrappedData)

            for (int i = 0; i < csvData.arrayLength; i++) {
                newCsvData[i] = new Data() from newTemplateType

                // Copy the values before the new column.
                for (int j = 0; j < columnNumber - 1; j++) {
                    newCsvData[i]:.j = csvData[i]:.j
                    // out.print("newCsvData[$(i)]:.$(j) = $(newCsvData[i]:.j)\n")
                    }

                // Copy the new column value.
                newCsvData[i]:.columnNumber = columnValues[i]

                // Copy the values after the new column.
                for (int j = columnNumber + 1; j < newTemplateType.fields.arrayLength; j++) {
                    newCsvData[i]:.j = csvData[i]:.j
                    // out.print("newCsvData[$(i)]:.$(j) = $(newCsvData[i]:.j)\n")
                    }
                }
            }
            else if (typeof(wrappedData[0]).fields[0].type.class == Type.DECIMAL) {
            dec columnValues[] = unwrapDecArray(wrappedData)

            for (int i = 0; i < csvData.arrayLength; i++) {
                // Copy the values before the new column.
                for (int j = 0; j < columnNumber - 1; j++) {
                    newCsvData[i]:.j = csvData[i]:.j
                    // out.print("newCsvData[$(i)]:.$(j) = $(newCsvData[i]:.j)\n")
                    }

                // Copy the new column value.
                newCsvData[i]:.columnNumber = columnValues[i]

                // Copy the values after the new column.
                for (int j = columnNumber + 1; j < newTemplateType.fields.arrayLength; j++) {
                    newCsvData[i]:.j = csvData[i]:.j
                    // out.print("newCsvData[$(i)]:.$(j) = $(newCsvData[i]:.j)\n")
                    }
                }
            }
            else {
            throw new Exception("Unsupported column type.")
            }

        // out.print("Total number of rows: $(rows.arrayLength)")

        // out.print("Header line = $(headerLine).")

        // // Build the new type.
        // // Check if the values array is of a type that has a single field.
        // if (typeof(columnValue).fields.arrayLength != 1) {
        //     throw new Exception("New column is of composite type.")
        //     return false
        //     }

        // // Get the type of the current CSV file from the template and add the additional field for the new column.
        // Type templateType = typeof(template)

        // Type newType
        // newType.fields = new Field[](dana.sub(templateType.fields, 0, columnNumber), typeof(columnValue).fields,
        //                              dana.sub(templateType.fields, columnNumber + 2, templateType.fields.arrayLength + 1))

        // out.print("The templateType array length: $(templateType.fields.arrayLength)")
        // out.print("The newType array length: $(newType.fields.arrayLength)")

        // for (int i = 0; i < newType.fields.arrayLength; i++) {
        //     out.print("Field $(i) = $(newType.fields[i].name)")
        //     }

        // for (int i = 0; i < templateType.fields.arrayLength - columnNumber; i++) {

        //     }

        // Parse the CSV file.
        // TODO: Check to see if the new column has compatible size.
        // Loop through the returned array and expand the 
        return false
        }

        /**
         * TODO: Make it so that arrays of integers of different sizes can be passed.
         */
        Data[] CSVUtilExtension:wrapIntArray(int intArray[]) {
            // Construct the array cell type.
            Type cellType = new Type(Type.DATA, 0, 0, new Field(new Type(Type.INTEGER, 0, 512), "Integer"))
            // Construct the array type.
            // TODO: Not sure if this has to have a size.
            Type arrayType = new Type(Type.ARRAY, 0, 0, new Field(cellType, "WrappedInteger"))

            Data curCell = new Data() from cellType
            Data curArray[] = new Data[] from arrayType

            // Construct the array itself.
            for (int i = 0; i < intArray.arrayLength; i++) {
                curCell:.0 = intArray[i]
                curArray = new Data[](curArray, rclone curCell)
                }

            return curArray
            }

        /**
         * TODO: Make it so that arrays of integers of different sizes can be returned.
         */
        int[] CSVUtilExtension:unwrapIntArray(Data dataArray[]) {
            // Construct the array to be returned.
            int curArray[] = new int[]

            for (int i = 0; i < dataArray.arrayLength; i++) {
                curArray = new int[](curArray, dataArray[i]:.0)
                }

            return curArray
            }

        /**
         * TODO: Make it so that arrays of integers of different sizes can be passed.
         */
        Data[] CSVUtilExtension:wrapDecArray(dec decArray[]) {
            // Construct the array cell type.
            Type cellType = new Type(Type.DATA, 0, 0, new Field(new Type(Type.DECIMAL, 0, 512), "Decimal"))
            // Construct the array type.
            // TODO: Not sure if this has to have a size.
            Type arrayType = new Type(Type.ARRAY, 0, 0, new Field(cellType, "WrappedDecimal"))

            Data curCell = new Data() from cellType
            Data curArray[] = new Data[] from arrayType

            // Construct the array itself. 
            for (int i = 0; i < decArray.arrayLength; i++) {
                curCell:.0 = decArray[i]
                curArray = new Data[](curArray, rclone curCell)
                }

            return curArray
            }

        /**
         * TODO: Make it so that arrays of integers of different sizes can be returned.
         */
        dec[] CSVUtilExtension:unwrapDecArray(Data dataArray[]) {
            // Construct the array to be returned.
            dec curArray[] = new dec[]

            for (int i = 0; i < dataArray.arrayLength; i++) {
                curArray = new dec[](curArray, dataArray[i]:.0)
                }

            return curArray
            }
    }